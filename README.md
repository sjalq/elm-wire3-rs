# elm-wire3-rs

Wire3 binary codec for Rust ↔ Elm interop. Parse Elm type definitions, generate Rust types with encode/decode, communicate over WebSocket.

Byte-compatible with [Lamdera](https://lamdera.com)'s `Wire3.elm` format — the same binary encoding used for Lamdera's backend↔frontend communication.

## What is Wire3?

Wire3 is Lamdera's compact binary serialization format. It uses zigzag varints for integers, IEEE 754 LE for floats, alphabetically sorted fields/constructors, and a handful of hardcoded tags for Maybe, Result, and Order. `lamdera make` auto-generates Wire3 codecs for all your Elm types.

This crate lets Rust speak the same binary language, enabling a **Rust backend** to communicate with an **Elm frontend** using type-safe binary messages over WebSocket — no JSON, no parsing overhead.

## Quick Start

### 1. Define your Elm message types

```elm
-- Messages.elm
module Messages exposing (..)

type ToBackend
    = AddTask String
    | ToggleTask Int
    | DeleteTask Int

type ToFrontend
    = TaskList (List Task)
    | TaskAdded Task

type alias Task =
    { id : Int, title : String, completed : Bool }
```

### 2. Generate Rust types

```bash
elm-wire3-rs Messages.elm -o src/messages.rs
```

This produces Rust structs and enums with `wire3_encode` / `wire3_decode` methods, byte-compatible with the Elm-side codecs generated by `lamdera make`.

### 3. Use in your Rust server

```rust
use elm_wire3_rs::wire3::{Wire3Encoder, Wire3Decoder};
use messages::{ToBackend, ToFrontend, Task};

// Decode incoming message
let mut dec = Wire3Decoder::new(&ws_bytes);
let msg = ToBackend::wire3_decode(&mut dec)?;

// Encode response
let mut enc = Wire3Encoder::new();
ToFrontend::TaskAdded(task).wire3_encode(&mut enc);
ws.send(enc.into_bytes());
```

## Architecture

```
Elm app                                              Rust server
  |                                                      |
  |  w3_encode_ToBackend msg                             |
  |  -> Bytes -> bytesToList -> List Int                 |
  |  -> port wire3WsSend                                 |
  |       |                                              |
  |  [wire3-ws.js: Uint8Array -> binary WS frame]        |
  |       |                                              |
  |       '------- binary WebSocket --------->  Wire3Decoder
  |                                             -> ToBackend enum
  |                                                      |
  |                                             Wire3Encoder
  |  <-------- binary WebSocket --------------  -> Vec<u8>
  |       |                                              |
  |  [wire3-ws.js: ArrayBuffer -> List Int]              |
  |       |                                              |
  |  port wire3WsReceived                                |
  |  -> listToBytes -> w3_decode_ToFrontend              |
  |  -> ToFrontend value                                 |
```

**Key insight**: Elm ports only support `String`, `Int`, `List`, etc. — not `Bytes`. So the JS bridge (`wire3-ws.js`) converts between `List Int` (Elm ports) and binary WebSocket frames. The wire is pure binary — no hex encoding, no JSON.

## Supported Elm Types

| Elm Type | Rust Type |
|----------|-----------|
| `Int` | `ElmInt` (53-bit safe) |
| `Float` | `ElmFloat` (f64) |
| `Bool` | `bool` |
| `String` | `String` |
| `Char` | `ElmChar` |
| `List a` | `Vec<A>` |
| `Array a` | `Vec<A>` |
| `Set comparable` | `BTreeSet<T>` |
| `Dict k v` | `BTreeMap<K, V>` |
| `Maybe a` | `Option<A>` |
| `Result e a` | `Result<A, E>` |
| `Order` | `ElmOrder` |
| `()` | `()` |
| `(a, b)` | `(A, B)` |
| `(a, b, c)` | `(A, B, C)` |
| Records | Named structs |
| Custom types | Enums |

## elm-pkg-js WebSocket Module

Drop `js/wire3-ws.js` into your project. It provides these Elm ports:

```elm
port wire3WsConnect : String -> Cmd msg        -- connect to URL
port wire3WsDisconnect : () -> Cmd msg         -- close connection
port wire3WsSend : List Int -> Cmd msg          -- send bytes
port wire3WsReceived : (List Int -> msg) -> Sub msg  -- receive bytes
port wire3WsStatus : (String -> msg) -> Sub msg      -- "connected" / "disconnected" / "reconnecting"
```

Auto-reconnects with exponential backoff. Sends/receives binary WebSocket frames.

## Example: Task Manager

A complete working example in `examples/tasks/` — Elm frontend + Rust/axum backend communicating via binary Wire3 over WebSocket.

```bash
cd examples/tasks
bash build.sh   # generates Rust types, builds Elm + Rust
cargo run        # starts server on http://localhost:3000
```

The Rust server logs every Wire3 message with byte counts:

```
  Wire3 Task Manager
  http://localhost:3000

[12:34:56] Client connected
[12:34:56] <- RequestTasks                     [1 bytes]
[12:34:56] -> TaskList([])                     [2 bytes]
[12:34:58] <- AddTask("Buy groceries")         [16 bytes]
[12:34:58] -> TaskAdded(Task { id: 1, .. })    [20 bytes]
```

## Testing

71 tests including bidirectional fuzz testing with randomly generated types:

```bash
cargo test
```

The fuzz test randomly generates Elm type definitions, compiles them with `lamdera make`, generates Rust types, creates random instances, and verifies Wire3 encode/decode byte-for-byte compatibility in both directions.

## License

MIT
